<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Navigation 살펴보기 - 03]]></title>
    <url>%2F2018%2F12%2F14%2FReact%20Navigation%20%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0%20-%2003%2F</url>
    <content type="text"><![CDATA[React Navigation 살펴보기 - 03 정리 목적으로 작성한 글 입니다 목표 : React Navigation 공식문서에 소개된 기본 동작 다뤄보기 환경 1234MacOS MojaveNode.js 8.14.1Npm 6.5.0 / yarn 1.12.3React Navigation 3.0.X Parameter 전달 아래와 같이 이동할 경로에 Parameter를 전달 할 수 있다 1this.props.navigation.navigate('RoutName', &#123; /* 전달할 파라메터 입력 */ &#125;); 전달된 Parameter 값은 아래와 같이 받아온다 1this.props.navigation.getparam(paramName, defaultValue); 지난번 만들었던 HomeScreen에서 DetailScreen으로 파라메터 전달 App.js파일 안에 HomeScreen 수정 1234567891011121314151617181920...class HomeScreen extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: "center", justifyContent: "center"&#125;&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title="Go to Details" onPress=&#123;() =&gt; &#123; this.props.navigation.navigate('Details', &#123; itemId: 86, otherParam: 'anything you want here', &#125;); &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;... this.props.navigation.navigate()의 두 번째 인자에 정의된 객체가 Parameter로 전달된다 App.js파일 안에 DetailsScreen 수정 12345678910111213141516171819202122232425262728293031...class DetailScreen extends React.Component &#123; render() &#123; const itemId = this.props.navigation.getParam('itemId', 'no-ID'); const otherParam = this.props.navigation.getParam('otherParam', 'some default value'); return ( &lt;View style=&#123;&#123; flex: 1, alignItems: "center", justifyContent: "center"&#125;&#125;&gt; &lt;Text&gt;Detail Screen&lt;/Text&gt; &lt;Text&gt;itemId: &#123;JSON.stringify(itemId)&#125;&lt;/Text&gt; &lt;Text&gt;itemId: &#123;JSON.stringify(otherParam)&#125;&lt;/Text&gt; &lt;Button title="Go to Details.. again" onPress=&#123;() =&gt; this.props.navigation.push('Details', &#123; itemId: Math.floor(Math.random() * 100), &#125;) &#125; /&gt; &lt;Button title="Go to Home" onPress=&#123;() =&gt; this.props.navigation.navigate('Home')&#125; /&gt; &lt;Button title="Go back" onPress=&#123;() =&gt; this.props.navigation.goBack()&#125; /&gt; &lt;/View&gt; ); &#125;... const itemId = this.props.navigation.getParam(&#39;itemId&#39;, &#39;no-ID&#39;); 전달된 Parameter에 itemId 키값을 저장 하되, 만약 값이 없다면 “no-ID” 저장 const otherParam = this.props.navigation.getParam(&#39;otherParam&#39;, &#39;some default value&#39;); 전달된 Parameter에 otherParam 키값을 저장 하되, 만약 값이 없다면 “some default value” 저장 실행 결과]]></content>
      <categories>
        <category>Mobile</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>React Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Navigation 살펴보기 - 02]]></title>
    <url>%2F2018%2F12%2F08%2FReact%20Navigation%20%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0%20-%2002%2F</url>
    <content type="text"><![CDATA[React Navigation 살펴보기 - 02 정리 목적으로 작성한 글 입니다 목표 : 공식문서에 소개된, React Navigation 기본 동작 다뤄보기 환경 1234Windows 10Node.js 8.11.2Npm 6.4.1 / yarn 1.7.0React Navigation 3.0.X 스크린 이동하기 지난번 포트스에 이어서 작성 두 스크린 사이를 이동하기 위해 지난번에 만든 HomeScreen과 DetailsScreen을 수정 먼저 createStackNavigator()에서 initialRouteName을 Home으로 변경 12345678910...const AppNavigator = createStackNavigator( &#123; Home: HomeScreen, Details: DetailScreen, &#125;, &#123; initialRouteName: "Home" &#125;);.. App.js에서 HomeScreen 클래스에 아래 내용 추가 12345678910111213141516... // Button import 필요class HomeScreen extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: "center", justifyContent: "center"&#125;&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title="Go to Details" onPress=&#123;() =&gt; this.props.navigation.navigate('Details')&#125; /&gt; &lt;/View&gt; ); &#125;&#125; this.props.navigation.navigate(‘Details’) 모든 스크린은 createStackNavigator()에 등록된 모든 스크린의 props에는 navigation 객체가 전달된다. 버튼 클릭시 DetailsScreen으로 이동은 &lt;a href=&quot;details.html&quot;&gt;Go&lt;/a&gt;과 유사하다 App.js에서 DetailsScreen 클래스에 아래 내용 추가 123456789101112131415...class DetailScreen extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: "center", justifyContent: "center"&#125;&#125;&gt; &lt;Text&gt;Detail Screen&lt;/Text&gt; &lt;Button title="Go to Details... again" onPress=&#123;() =&gt; this.props.navigation.navigate('Home')&#125; /&gt; &lt;/View&gt; ); &#125;&#125;...]]></content>
      <categories>
        <category>Mobile</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>React Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NestJS와 MongoDB 그리고 Swagger]]></title>
    <url>%2F2018%2F12%2F02%2FNestJS%EC%99%80%20MongoDB%20%EA%B7%B8%EB%A6%AC%EA%B3%A0%20Swagger%2F</url>
    <content type="text"><![CDATA[NestJS와 MongoDB 그리고 Swagger 정리 목적으로 작성한 글 입니다 목표 : NestJS와 MongoDB를 이용해 간단한 API를 만들고, Swagger를 적용하여 API 문서화 해보기 참고 Nest.js 공식문서 : https://docs.nestjs.com Nest.js ? Nest.js는 Express기반에 서버사이드 프레임워크로 Typescript(ES6도 가능)를 적용하여, Javascript의 유연함은 물론 유지보수나 구조화에 유리한 OOP 방식의 프로그래밍을 동시에 적용 할 수 있다 Nest.js에 목적은 공홈에 소개하고 있듯이 프론트앤드의 Angular, React, Vue와 같은 생산성을 서버 사이드에서 제공하는 것이다. 사용해본 결과 프론트앤드 프래임워크인 Angular 2+와 유사한 구조를 제공하는데 서버사이드 Angular라고 불러도 될만큼 유사하다 처음 Nest.js를 알게된 약 1년 반 전 깃허브 스타 4천대에서 현재 1만 1천 이상으로 급증할 만큼 인기가 늘고 있다. 그와 동시에 참고할만한 훌륭한 문서도 많아졌다. 그동안 Typescript와 Inversify 라이브러리 등을 활용해서 Angular 2+ 구조를 모방하여 사용해 왔는데, 이번 토이 프로젝트는 편리하게 Nest.js로 진행 할 수 있을 것 같다 공식홈페이지 메인에 있는 맹수 배경과 공식 마크가 제공하는 기능만큼이나 매우 강렬하다 Nest.js 및 관련 패키지 설치 Nest.js도 CLI를 제공한다. 아래와 같이 CLI를 설치 후 프로젝트 생성은 아래와 같다 12$ npm i -g @nestjs/cli$ nest new nest-mongo-swagger 스타터 프로젝트를 직접 클론해서 사용하는 것도 가능 1234$ git clone https://github.com/nestjs/typescript-starter.git nest-mongo-swagger$ cd nest-mongo$ npm install$ npm run start Mongoose 설치 12$ yarn add mongoose @nestjs/mongoose$ yarn add @types/mongoose --dev Nest.js에서 제공하는 @nestjs/mongoose 패키를 사용하면, 프레임워크에서 제공하는 구조에 적합한 방식으로 개발 할 수 있다. 물론 사용하지 않는 방법도 공식 문서에 잘 설명하고 있지만 제공되는 기능을 활용해 보기로 한다 Swagger 설치 1$ yarn add @nestjs/swagger Swagger같은 API문서 자동화 도구를 사용해 본적은 없지만, Nest.js 문서에 너무 잘 설명되어 있어서 이번 기회에 적용해보기로 했다 Swagger 설정 main.ts를 수정하여 Swagger관련 기능을 등록해 준다 12345678910111213141516171819import &#123; NestFactory &#125; from '@nestjs/core';import &#123; SwaggerModule, DocumentBuilder &#125; from '@nestjs/swagger';import &#123; ApplicationModule &#125; from './app.module';async function bootstrap() &#123; const app = await NestFactory.create(ApplicationModule); const options = new DocumentBuilder() .setTitle('Nest.js, MongoDB with swagger example') .setDescription('API description') .setVersion('1.0') .addTag('API List') .build(); const document = SwaggerModule.createDocument(app, options); SwaggerModule.setup('api', app, document); await app.listen(3000);&#125;bootstrap(); const options = new DocumentBuilder() … 웹 기반의 Swagger UI에 표시될 기본 정보를 입력한다 const document = SwaggerModule.createDocument(app, options); Nest.js 앱과 위에서 설정한 기본 정보를 Swagger 모듈에 등록한다 SwaggerModule.setup(‘api’, app, document); ‘api’는 Swagger UI 진입점이 된다. http://localhost:3000/api와 같이 접근 가능 http://localhost:3000/api에 접속하면 입력한 정보들을 확인 할 수 있다 MongoDB 연결 app.module.ts파일에 아래내용 추가 1234567891011import &#123; Module, NestModule &#125; from '@nestjs/common';import &#123; MongooseModule &#125; from '@nestjs/mongoose';@Module(&#123; imports: [ MongooseModule.forRoot('mongodb://xxx.xxx.xxx.xxx/nest-mongo'),], controllers: [], providers: [],&#125;)export class AppModule &#123;&#125; MongooseModule.forRoot(‘mongodb://xxx.xxx.xxx.xxx/nest-mongo’), MongoDB Server에 “nest-mongo” Database에 접속 한다 추가 정보는 두 번째 인자로 MongooseModuleOptions 타입의 객체를 전달하여 설정 가능하다 간단한 API 만들기 제목과 간단한 메모를 저장할 Database를 생성하고 CRUD를 통해 서비스하는 API를 생성 하려고 한다 이후 생성되는 모든 기능은 memos 폴더 아래 생성한다 Mongoose DB Schema 생성 Schema는 일반적인 ORM에 Model, 혹은 TypeORM에 Entity와 같은 개념 memos/schemas/memo.schema.ts 파일을 생성하여 아래내용 작성 123456import * as mongoose from 'mongoose';export const MemoSchema = new mongoose.Schema(&#123; title: String, memo: String,&#125;); DTO 클래스 정의 Swagger와 데이터 베이스 사이에 데이터를 전달을 위한 DTO 클래스 생성 memos/dtos/createMemo.dto.ts 파일을 생성하여 아래내용 작성 12345678910import &#123; ApiModelProperty &#125; from '@nestjs/swagger';export class CreateMemoDto &#123; @ApiModelProperty() readonly title: string; @ApiModelProperty() readonly memo: string;&#125; 인터페이스 생성 컨트롤러와 서비스에서 사용할 인터페이스 파일을 정의 Mongoose 패키지의 Document를 상속받아 Schema 파일과 동일한 프로퍼티의 인터페이스를 만든다 memos/interfaces/memo.interface.ts 파일을 생성하여 아래내용 작성 123456import &#123; Document &#125; from 'mongoose';export interface IMemo extends Document &#123; readonly title: string; readonly memo: string;&#125; 모듈, 서비스, 컨트롤러 만들기 모듈? Nest.js는 Angular 2+와 같은 모듈 구조를 가진다 컨트롤러와 서비스를 최상위 모듈인 app.modules.ts에 등록해서 사용 할 수도 있지만 규모가 커지면 복잡해 질 수 있어 하위 모듈을 만들어 사용한다 하위 모듈에 컨트롤러와 서비스 등록후 하위 모듈을 app.modules.ts에 등록하는 방식으로 복잡성을 최소화 한다 모듈 만들기 memos/memos.module.ts 파일을 생성하여 아래내용 작성 123456789101112import &#123; Module &#125; from '@nestjs/common';import &#123; MemosController &#125; from './memos.controller';import &#123; MemosService &#125; from './memos.service';import &#123; MongooseModule &#125; from '@nestjs/mongoose';import &#123; MemoSchema &#125; from './schemas/memo.schema';@Module(&#123; imports: [MongooseModule.forFeature([&#123;name: 'Memo', schema: MemoSchema&#125;])], controllers: [MemosController], providers: [MemosService]&#125;)export class MemosModule &#123;&#125; imports 하위 모듈을 등록한다 @nestjs/mongoose에서 제공하는 MongooseModule을 이용하여 스키마와 스키마 이름을 등록해 준다 controllers 아직 컨트롤러(MemosController)를 만들지 않았지만 등록한다 providers 아직 서비스(MemosService)를 만들지 않았지만 등록한다 providers에 등록된 서비스는 해당 모듈 내부에서 언제든 재사용 가능하다 app.modules.ts에 memos/memos.modules.ts 등록 imports 부분에 MemosModule 추가 12345678...import &#123; MemosModule &#125; from './memos/memos.module';... imports: [ ... MemosModule, ], 서비스 만들기 memos/memos.service.ts 파일을 생성하여 아래내용 작성 123456import &#123; Injectable &#125; from '@nestjs/common';@Injectable()export class MemosService &#123; ...&#125; @Injectable() “Injectable” 단어 그대로의 의미대로 다른 서비스 혹은 컨트롤러에 주입이 가능한 클래스를 생성하겠다는 의미이다 위 memos.module.ts에서 providers에 등록한 서비스는 바로 @Injectable() 데코레이터를 갖고 있는 클래스를 의미한다 providers에 등록하면 Nest.js에서 제공하는 IOC컨테이너에 객체에 대한 제어권을 넘겨주겠다는 의미로, 이후 해당 서비스를 사용할때 new 연산자 등으로 일일이 객체를 생성할 필요 없이 @Inject() 데코레이터와 함께 주입하여 사용이 가능 주입되는 서비스는 사용하는 곳에서 매번 새로운 객체를 생성는데, 필요한 경우 싱글톤 객체 생성도 가능 하다 생성한 memos.service.ts 파일에 아래내용 추가 mongoose에서 제공하는 모델에 직접 접근하여 일반적인 CRUD 동작을 수행한다 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; Injectable &#125; from '@nestjs/common';import &#123; Model &#125; from 'mongoose';import &#123; InjectModel &#125; from '@nestjs/mongoose';import &#123; IMemo &#125; from './interfaces/memo.interface';import &#123; CreateMemoDto &#125; from './dtos/createMemo.dto';import &#123; debug &#125; from 'console';@Injectable()export class MemosService &#123; constructor(@InjectModel('Memo') private readonly memoModel: Model&lt;IMemo&gt;) &#123;&#125; async findAll(): Promise&lt;IMemo[]&gt; &#123; return await this.memoModel.find().exec(); &#125; async findOne(options: object): Promise&lt;IMemo&gt; &#123; return await this.memoModel.findOne(options).exec(); &#125; async findById(id: number): Promise&lt;IMemo&gt; &#123; return await this.memoModel.findById(id).exec(); &#125; async create(createMemoDto: CreateMemoDto): Promise&lt;IMemo&gt; &#123; const createMemo = new this.memoModel(createMemoDto); return await createMemo.save(); &#125; async update(id: number, newValue: IMemo): Promise&lt;IMemo&gt; &#123; const memo = await this.memoModel.findById(id).exec(); if (!memo._id) &#123; debug('memo not found'); &#125; await this.memoModel.findByIdAndUpdate(id, newValue).exec(); return await this.memoModel.findById(id).exec(); &#125; async delete (id: number): Promise&lt;string&gt; &#123; try &#123; await this.memoModel.findByIdAndRemove(id).exec(); return 'deleted data'; &#125; catch (err) &#123; debug(err); return 'not be deleted'; &#125; &#125;&#125; constructor(@InjectModel(‘Memo’) private readonly memoModel: Model) {} @InjectModel(‘Memo’) : memos.module.ts에 MongoosModule 등록시 설정했던 스키마를 사용 private readonly memoModel: Model 서비스 내에서 memoModel이란 이름으로 접근하고 타입은 Model async create(createMemoDto: CreateMemoDto): Promise Swagger UI를 통해 받는 메모 데이터를 사용 컨트롤러 만들기 일반적으로 Express에서 Router를 사용하여 URL과 실행 함수를 연결하는 것과 유사하다 memos/memos.controller.ts 파일을 생성하여 아래내용 작성 12345678910import &#123; Controller&#125; from '@nestjs/common';import &#123; ApiUseTags, ApiResponse &#125; from '@nestjs/swagger';...@ApiUseTags('memos')@Controller('memos')export class MemosController &#123; constructor(private readonly memosService: MemosService) &#123; &#125; ...&#125; @ApiUseTags(‘memos’) Swagger UI에서 접근하는 경로를 설정 하는 데코레이터 UI가 있기때문에 직접 접근 할일은 없지만, Swagger에서는 http://localhost:3000/api/memos/... 와 같이 URL이 구성된다 @Controller(‘memos’) 일반적인 라우터 접근 경로를 설정하는 데코레이터 constructor(private readonly memosService: MemosService) { } 위에서 생성한 서비스를 사용하기 위해 주입한다 따로 @Inject() 데코레이터를 사용하지 않고, 사용 하는것이 특징인데 이는 Nest.js 내부에서 지원해 주는 것 같다 생성한 memos.controller.ts 파일에 아래 내용추가 주입받은 서비스 객체를 통해서 데이터베이스에 접근하여 CRUD 서비스를 제공한다 서비스는 다른 라우터에서도 언제든 재사용 가능하다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#123; Controller, Get, Response, HttpStatus, Param, Body, Post, Patch, Delete&#125; from '@nestjs/common';import &#123; MemosService &#125; from './memos.service';import &#123; CreateMemoDto &#125; from './dtos/createMemo.dto';import &#123; ApiUseTags, ApiResponse &#125; from '@nestjs/swagger';@ApiUseTags('memos')@Controller('memos')export class MemosController &#123; constructor(private readonly memosService: MemosService) &#123; &#125; @Get() public async getMemos(@Response() res) &#123; const memos = await this.memosService.findAll(); return res.status(HttpStatus.OK).json(memos); &#125; @Get('find') public async findMemo(@Response() res, @Body() body) &#123; const queryCondition = body; const memos = await this.memosService.findOne(queryCondition); return res.status(HttpStatus.OK).json(memos); &#125; @Get('/:id') public async getMemo(@Response() res, @Param() param) &#123; const memos = await this.memosService.findById(param.id); return res.status(HttpStatus.OK).JSON(memos); &#125; @Post() @ApiResponse(&#123; status: 201, description: 'The record has benn successfully created.'&#125;) @ApiResponse(&#123; status: 403, description: 'Forbidden.'&#125;) public async createMemo(@Response() res, @Body() createMemoDTO: CreateMemoDto) &#123; const memo = await this.memosService.create(createMemoDTO); return res.status(HttpStatus.OK).json(memo); &#125; @Patch('/:id') public async updateMemo(@Param() param, @Response() res, @Body() body) &#123; const memo = await this.memosService.update(param.id, body); return res.status(HttpStatus.OK).json(memo); &#125; @Delete('/:id') public async deleteMemo(@Param() param, @Response() res) &#123; const memo = await this.memosService.delete(param.id); return res.status(HttpStatus.OK).json(memo); &#125;&#125; @ApiResponse … 응답코드에 관한 정보와, 설명을 Swagger UI에 표시한다 public async createMemo(@Response() res, @Body() createMemoDTO: CreateMemoDto){} Swagger UI를 통해 받는 메모 데이터(CreateMemoDto) 사용 완성된화면 생성된 API 목록과 아래쪽에 Model까지 표시 * Post 요청 테스트 &lt;br&gt;]]></content>
      <categories>
        <category>Backend</category>
        <category>Express</category>
        <category>Nest.js</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Express</tag>
        <tag>Typescript</tag>
        <tag>Nest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative(Expo)에 Mobx(ES6) 적용하기]]></title>
    <url>%2F2018%2F11%2F27%2FReactNative(Expo)%EC%97%90%20Mobx(ES6)%20%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%2F</url>
    <content type="text"><![CDATA[ReactNative(Expo)에 Mobx(ES6) 적용하기 정리 목적으로 작성한 글 입니다 목표 : Expo CLI를 통해 생성된 ES6 프로젝트에 Mobx 적용하기 Why? ES6 지금까지 까지 Typescript를 사용했지만, 한가지 아쉬운점은 레퍼런스가 부족하다는점이다. 다행히 Server와 Web까지는 1~2년 전보다 생태계가 급격히 발전하여 좋은 레퍼런스가 생겨나고 있어 Typescript를 적용하기 좋은 환경이 갖추어졌다. 하지만 Expo에서는 Typescript에 관한 레퍼런스가 적어, 당분간 Tyepscript를 고집하지 않고 ES6를 사용하고, 추후 조금더 생태계가 조성되면 Typescript를 사용 해야겠다. 환경 123Windows 10Node.js 8.11.2Expo CLI 2.X (Ver 2.x → CRNA 기능 통합, XDE 웹기반으로 변경) Expo CLI 설치 1$ yarn global expo-cli ※ 또는 npm isntall -g expo-cli 프로젝트 생성 1$ expo init &lt;Project Name&gt; ※ "blank app" 선택 MobX 설치 12$ cd &lt;Project Name&gt;$ yarn add mobx mobx-react 데코레이터 관련 Babel 플러그인 설치 1$ yarn add @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties --dev babel.config.js 파일에 플러그인 적용 12345678910module.exports = function(api) &#123; api.cache(true); return &#123; presets: ['babel-preset-expo'], plugins: [ ['@babel/plugin-proposal-decorators', &#123; legacy: true &#125;], ['@babel/plugin-proposal-class-properties', &#123; "loose": true&#125;] ] &#125;;&#125;; 단순한 카운터를 만들기 위해 카운터 스토어를 생성 엔트리파일 변경 123$ mkdir src$ mv App.js ./src$ touch App.js App.js 파일변경 12import App from './src/App';export default App; Store 생성 src/stores폴더 생성 src/stores/CounterStores.ts 파일 생성 후 아래 내용을 입력 12345678910111213141516171819import &#123; observable, action &#125; from 'mobx';export class CounterStore &#123; @observable counter; constructor() &#123; this.counter = 0; &#125; @action increase = () =&gt; &#123; this.counter++; &#125; @action decrease = () =&gt; &#123; this.counter--; &#125;&#125; src/stores/createStores.js 파일 생성 후 아래 내용을 입력 123456789import &#123; CounterStore &#125; from './CounterStore';export function createStores() &#123; const counterStore = new CounterStore(); // CounterStore 객체 생성 return &#123; counterStore, &#125;;&#125; src/App.js 파일에 Store를 등록 1234567891011121314151617181920...import &#123; Provider &#125; from 'mobx-react';import &#123; createStores &#125; from './stores/createStores';import Counter from './Components/Counter';const stores = createStores();export default class App extends React.Component &#123; render() &#123; return ( &lt;Provider &#123;...stores&#125;&gt; &lt;View style=&#123;styles.container&#125;&gt; &lt;Counter /&gt; &lt;/View&gt; &lt;/Provider&gt; ); &#125;&#125;... src/components/Counter/index.js 파일을 생성하여 Store 사용 테스트 12345678910111213141516171819202122232425import React from 'react';import &#123; Text, View, Button &#125; from 'react-native';import &#123; observer, inject &#125; from 'mobx-react';@inject('counterStore')@observerexport default class App extends React.Component &#123; render() &#123; const &#123; counter, increase, decrease&#125; = this.props.counterStore; return ( &lt;View&gt; &lt;Text&gt;&#123;counter&#125;&lt;/Text&gt; &lt;Button onPress=&#123;increase&#125; title="Increase" /&gt; &lt;Button onPress=&#123;decrease&#125; title="Decrease" /&gt; &lt;/View&gt; ); &#125;&#125; 만약 VS Code를 사용하고 있다면 ES6를 사용함에도 불구하고, 데코렝터 에서 tslint 경고가 발생하는데, 아래 방법으로 경고 해제 Root 폴더 아래 tsconfig.json파일을 생성후 아래 내용을 입력 123456&#123; "compilerOptions": &#123; "experimentalDecorators": true, "allowJs": true &#125;&#125; ​]]></content>
      <categories>
        <category>Mobile</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>Mobx</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Navigation 살펴보기 - 01]]></title>
    <url>%2F2018%2F11%2F23%2FReact%20Navigation%20%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0%20-%2001%2F</url>
    <content type="text"><![CDATA[React Navigation 살펴보기 - 01 정리 목적으로 작성한 글 입니다 목표 : 공식문서에 소개된, React Navigation 기본 동작 다뤄보기 환경 1234Windows 10Node.js 8.11.2Npm 6.4.1 / yarn 1.7.0React Navigation 3.0.X React Navigation 패키지 설치 12$ yarn add react-navigation$ yarn add react-native-gesture-handler # expo 사용시 실치 및 MainActivity.java 수정필요 없음 ※ 공홈 참조 Expo 프로젝트 생성 1$ expo init &lt;Project Name&gt; ※ &quot;blank app&quot; 선택 React Navigation 시작 Stack Navigator 브라우저에서 사용자가 &lt;a&gt;태그(anchor tag)를 클릭 후 뒤로가기 버튼을 누르는 경우 global history stack에 화면을 push/pop하여 기록한다. ReactNative는 global history stack은 갖고 있지 않지만, 유사한 개념의 Stack Navigator를 제공 한다. 브라우저와 다른점은, Stack Navigator는 stack의 경로를 탐색할때 iOS와 Android에 제스처와 애니메이션을 제공한다는 점이다. 엔트리 포인트 변경 123$ mkdir src$ cp App.js ./src$ touch App.js 123// App.js 파일import App from './src/App';export default App; Stack Navigator 작성 src/App.js에 HomeScreen 컴포넌트 추가 123456789class HomeScreen extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: "center", justifyContent: "center" &#125;&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; src/App.js에 DetailsScreen 컴포넌트 추가 123456789class HomeScreen extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: "center", justifyContent: "center" &#125;&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; src/App.js에 Stack Navigator 생성 및 AppContainer 생성 12345678910111213import &#123; createStackNavigator, createAppContainer &#125; from "react-navigation";...const AppNavigator = createStackNavigator( &#123; Home: HomeScreen, Details: DetailsScreen, &#125;, &#123; initialRouteName: "Details" &#125;);const AppContainer = createAppContainer(AppNavigator); initialRouteName에 따라 처음 렌더링 되는 화면이 달라집니다. src/App.js에 App 컴포넌트 아래와 같이 수정 1234567export default class App extends React.Component &#123; render() &#123; return ( &lt;AppContainer /&gt; ); &#125;&#125; 결과 실행하면 화면 상단에 Appbar가 생기고, initialRuteName에 입력된 초기 화면이 렌더링 되는 것을 볼 수 있다]]></content>
      <categories>
        <category>Mobile</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>React Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[비동기 프로그래밍과 콜백 함수]]></title>
    <url>%2F2018%2F11%2F23%2F%EB%B9%84%EB%8F%99%EA%B8%B0%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC%20%EC%BD%9C%EB%B0%B1%20%ED%95%A8%EC%88%98%2F</url>
    <content type="text"><![CDATA[비동기 프로그래밍과 콜백 함수 정리 목적으로 작성한 글 입니다 비동기 프로그래밍과 콜백 함수 자바스크립트는 싱글스레드(single-threaded) 프로그래밍 언어 이므로 하나의 콜스택(Call Stack)을 갖고 있다 예를 들어 A함수 내부에서 B함수를 실행시키는 경우 콜스택을 보면, A함수, B함수 순으로 콜스택에 저장 된다 나중에 입력된 B함수 먼저 실행후 순차적으로 A함수가 실행 된다 위 동작을 코드와 이미지로 보면 아래와 같다 123456789function funcB() &#123; ...&#125;function funcA() &#123; funcB();&#125;funcA(); 만약, 콜스택에서 실행되는 함수가 실행 시간이 길거나, 응답을 대기해야 하는 함수인 경우 브라우저 또는 Node.js는 블록킹 상태 된다 블록킹 상태에서, Node.js 서버는 다른 요청을 처리 할 수 없고, 브라우저는 UI가 응답대기 상태로 멈춰있게 되어 부정적인 사용자 경험을 제공 따라서 브라우저와 Node.js는 논블록킹 방식의 함수들을 제공하여 비동기 동작을 기본으로 한다 (블록킹 방식의 함수도 제공) 논블록킹 방식의 함수는 실행 지점에서 결과를 받을때 까지 대기하지 않고, 바로 다음 구문을 실행 하므로 결과는 콜백 함수를 이용해 나중에 처리 한다 대표적인 논블록킹(비동기) 함수인 fs.readFile()는 아래 코드와 같이, 콜백함수를 통해 결과를 처리하며, 블록킹 되지 않기 때문에 바로 다음에 호출되는 console.log()를 처리한다 123456789101112const fs = require('fs');fs.readFile('/file.md', (err, data) =&gt; &#123; if (err) throw err; console.log('result'); // 콜백함수를 통해 결과를 처리&#125;);console.log('after read file'); // fs.readfile() 이후 바로 실행//// 실행결과after read fileresult 블록킹과 논블록킹을 http 요청/응답을 예로들어 타임라인 상에 표현해보면 아래와 같다 이벤트 루프(event loop)와 콜백큐(callback queue)는 콜백 함수들을 관리한다 이벤트 루프와 콜백큐는 웹 API(Node.js의 경우 C++ API) 같이 자바스크립트 엔진 외부에 존재 자바스크립트 엔진 내부에 함수가 실행되면 콜스택에 저장되고, 콜백함수들은 콜백큐에 저장 이때, 이벤트 루프는 콜스택을 감시하다가 함수가 실행되어 콜스택이 비워지게 되면 콜백큐에 저장된 콜백함수를 실행한다 비동기 동작의 예로, 웹 API인 setTimeout()함수 호출시 코드는 아래와 같다 1234567console.log("Start!");setTimeout(function timeout() &#123; console.log("Timeout Callback!");&#125;, 2000);console.log("Next statement!"); 실행결과는 아래와 같다 123Start!Next Statement!Timeout Callback! 위 코드의 흐름을 그림으로 나타내보면 아래와 같다 자바 스크립트는 위와 같이 논블로킹 방식의 함수와 콜백 함수를 통해 단일 스레드에서 동시성(concurrency)을 제공한다]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>비동기</tag>
        <tag>asynchronous</tag>
        <tag>콜백</tag>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express에 Typescript와 Inversify 적용하기]]></title>
    <url>%2F2018%2F11%2F16%2FExpress%EC%97%90%20Typescript%EC%99%80%20Inversify%20%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%2F</url>
    <content type="text"><![CDATA[Express에 Typescript와 Inversify 적용하기 정리 목적으로 작성한 글 입니다 목표 : Express 프로젝트에 Typescript와 Inversify를 적용 환경 123Windows 10Node.js 8.11.2Npm 6.4.1 / yarn 1.7.0 프로젝트 생성 123$ mkdir &lt;프로젝트 폴더&gt;$ cd &lt;프로젝트폴더&gt;$ npm init ※ 요구하는 입력 사항은 상황에 따라 적당히 입력 yarn 설치 yarn 사용 1$ npm install -g yarn Typescript 관련 패키지 설치 1$ yarn add typescript ts-node --dev 루트 폴더 아래 tsconfig.json 파일 생성 후 아래 내용 추가 1234567891011121314151617181920212223&#123; "compilerOptions": &#123; "module": "commonjs", "target": "es6", "lib": [ "es6", "dom" ], "noImplicitAny": false, "sourceMap": true, "emitDecoratorMetadata": true, "experimentalDecorators": true, "moduleResolution": "node", "noUnusedLocals": true, "resolveJsonModule": true, "allowJs": true, "outDir": "./dist" &#125;, "compileOnSave": false, "exclude": [ "node_modules" ]&#125; express 관련 패키지 설치 Rest API를 만들것이므로, 템플릿 관련 패키지는 설치하지 않음 12$ yarn add express body-parser cors nodemon$ yarn add @types/express @types/body-parser @types/cors --dev body-parser 미들웨어 요청 데이터를 파싱하여 req.body객체로 접근하는 것을 도와주는 미들웨어 cors 미들웨어 CORS를 제한하는 브라우저 사용시 이를 피하기 위해 사용 nodemon 코드 수정시 서버를 자동을 갱신해주는 유틸 inversify 관련 패키지 설치 12$ yarn add reflect-metadata$ yarn add inversify inversify-binding-decorators inversify-express-utils reflect-metadata typescript의 데코레이터와 같이 실험적인 메타데이터 API를 사용하기 위해 필요한 라이브러리 inversify IOC 컨테이너 라이브러리로, angular2+와 같이 의존성 주입을 통해 서비스를 사용 할 수 있도록 해주는 라이브러리 이제부터 express를 구동을 위한 설정 엔트리 포인트 생성 루트 폴더 아래 index.js파일 생성 (package.json이 있는 폴더) 12require('ts-node/register');require('./src/bootstrap'); 파일생성 1234+-- src +-- controllers/Hello.controller.ts +-- services/Hello.service.ts bootstrap.ts 서비스파일 작성 Hello.service.ts 파일을 아래와 같이 작성 서비스를 통해 Controller와 관심사를 분리 하여 Controller 단순화 (여기서는 데이터베이스를 실제 조작하는 코드 작성) 1234567891011import &#123; injectable &#125; from 'inversify'@injectable()export class HelloService &#123; public getData() &#123; return &#123; state: "success", message: "Hello Express, Typescript, Inversify!", &#125; &#125;&#125; @injectable() 의존성 주입이 가능함을 명시해주는 데코레이터 IOC 컨테이너에 등록 하면 이후에는 의존성 주입을 통해 제어권을 컨테이너가 조정 서버시작 및 서비스 파일 등록 bootstrap.ts 파일을 아래와 같이 작성 12345678910111213141516171819202122232425262728293031323334353637383940import 'reflect-metadata';import * as bodyParser from 'body-parser';import * as cors from 'cors';import &#123; InversifyExpressServer &#125; from 'inversify-express-utils';import &#123; AsyncContainerModule, Container &#125; from 'inversify';import &#123; HelloService &#125; from './services/Hello.service';/* Bind Controller */const bindings = new AsyncContainerModule(async (bind) =&gt; &#123; await require('./controllers/Hello.controller');&#125;);async function bootstrap() &#123; /* Create IOC Container */ let inversify_ioc = new Container(); await inversify_ioc.loadAsync(bindings); /* Add Service */ inversify_ioc.bind&lt;HelloService&gt;('HelloService').to(HelloService); /* Express Server &amp; Middleware */ let server = new InversifyExpressServer(inversify_ioc); server.setConfig((app) =&gt; &#123; app.use(bodyParser.urlencoded(&#123;extended: true&#125;)); app.use(bodyParser.json()); app.use(cors()); &#125;); let serverBuild = server.build(); serverBuild.listen(3301, '127.0.0.1'); console.log(`Start server..`); console.log(`Listen server on port : 3301..`);&#125;bootstrap(); Bind Controller 이하 컨트롤러 파일을 Inversefy 컨테이너 모듈과 바인딩 URL을 컨트롤러 파일 내부 클래스/매소드와 맵핑 이후 생성되는 컨트롤러는 아래에 계속해서 추가 Add Service 이하 위에서 생성한 Hello.service.ts 파일을 컨테이너에 등록 일반적인 객체 뿐만 아니라 싱글톤등 다양한 형식을 지원 이후 생성되는 서비스는 아래에 계속해서 바인딩 Express Server &amp; Middleware 이하 inversify-express-util에서 제공하는 방식으로 Express 서버를 생성하고 미들웨어를 등록 컨트롤러 작성 Hello.controller.ts 파일 작성 123456789101112131415161718import * as express from 'express';import &#123; inject &#125; from 'inversify';import &#123; controller, httpGet, response, request &#125; from 'inversify-express-utils';import &#123; HelloService &#125; from '../services/Hello.service';@controller('/hello')export class HelloController &#123; constructor( @inject('HelloService') private _hello: HelloService ) &#123; &#125; @httpGet('/') public async getData(@response() res: express.Response, @request() req: express.Request) &#123; return res.status(200).json(this._hello.getData()) &#125;&#125; 위에서 생성한 Hello 서비스를 HelloController의 생성자에 private 멤버 변수로 주입 컨트롤러 내부에서는 this._hello를 통해 Hello서비스에 접근/사용 컨트롤러와 서비스가 분리되어 컨트롤러 로직이 훨씬 단순해짐 스크립트 등록 package.json의 scripts 부분을 수정 123456789&#123; ... "scripts": &#123; "start": "node index.js", "start:watch": "nodemon index.js", "start:prod": "rm -rf ./dist/ &amp;&amp; tsc &amp;&amp; node dist/index.js" &#125; ...&#125; 실행 1yarn start:watch # nodemon을 통해 실행]]></content>
      <categories>
        <category>Backend</category>
        <category>Express</category>
        <category>Typescirpt</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Express</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F13%2FReact%20Typescript%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%20MobX%20%EC%A0%81%EC%9A%A9%2F</url>
    <content type="text"><![CDATA[React Typescript 프로젝트에 MobX 적용 정리 목적으로 작성한 글 입니다 목표 : Typescript로 구성된 React 프로젝트에 MobX를 적용하고 Store 기반의 라우터 사용 환경 123Windows 10Node.js 8.11.2CRA 2.1.1 MobX ? MobX는 Redux와 함께 가장 인기있는 상태관리 라이브러리 중 하나 공식홈페이지에서는 MobX를 매우 단순하고 확장성이 좋다고 소개 하고 있다 MobX는 React가 상태를 저장하고 업데이트 하는 방식과 유사한 메커니즘을 제공하기 때문에 React와의 조합이 매우 좋다 프로젝트를 생성 후 MobX를 적용 crea-react-app으로 Typescript 프로젝트 생성 12$ npm install -g create-react-app$ create-react-app &lt;프로젝트명&gt; --scripts-version=react-scripts-ts mobx, react-router 설치 12$ cd &lt;프로젝트명&gt;$ yarn add mobx mobx-react mobX는 타이프스크립트로 작성되어, 타입정의파일(d.ts)이 별도 설치가 필요 없음 데코레이터를 사용하기 위해 tsconfig.json 파일에 아래내용 추가 1234567&#123; "compilerOptions": &#123; ..., "experimentalDecorators": true &#125;, ...&#125; (선택사항) tslint.json에 귀찮은 옵션을 해제 “ordered-imports”는 모듈 import시 A, B, C 순으로 호출하지 않을 경우 경고 발생 시키므로 해제 1234567&#123; ... "rules": &#123; "ordered-imports": false &#125; ...&#125; 디렉토리 구조 디렉토리 구조에 대한 대한 표준은 없이 개발자에 따라 다름 아래와 같은 구조로 폴더를 생성 1234567+-- src +-- stores ※ 여러개의 store 생성 가능 +-- constant ※ props로 전달되는 store 객체의 Key값으로 사용될 상수 +-- view +-- containers ※ store가 주입(inject)되는 컴포넌트 +-- components ※ props를 통해 container로부터 store데이터를 전달받음 (권장사항으로 component에서 직접 store를 주입해도 상관없습니다) 단순한 카운터를 예를 들어 스토어와 아래 컴포넌트를 생성 하기 Store 생성 src/stores/CounterStore.ts 파일 생성 후 아래 내용을 입력 123456789101112131415161718import &#123; observable, action &#125; from 'mobx';export class CounterStore &#123; @observable public counter: number; constructor() &#123; this.counter = 0; &#125; @action public increase = () =&gt; &#123; this.counter++; &#125; @action public decrease = () =&gt; &#123; this.counter--; &#125;&#125; 데코레이터 설명 @observable observer로 관찰 가능해짐, 즉 값이 변경되면 observer에게 알림 @action @observable값을 변경 시키는 경우 사용 Store를 구분하기 위한 키(상수) 등록 src/constant/stores.const.ts파일 생성후 아래 내용을 입력 정해진 형식이 없어 나름의 기준으로 이름 선정 1export const COUNTER_STORE = 'counter_store'; Store를 생성하기 위한 함수를 생성 src/stores/createStores.ts파일 생성후 아래 내용을 입력 이후 추가되는 Store는 모두 이곳에 추가 12345678910import &#123; CounterStore &#125; from './CounterStore';import &#123; COUNTER_STORE &#125; from 'src/constant/stores.const';export function createStores() &#123; const counterStore = new CounterStore(); // CounterStore 객체 생성 return &#123; [COUNTER_STORE]: counterStore, &#125;;&#125; Store 등록 src/index.tsx파일을 아래와 같이 수정 123456789101112131415...import &#123; Provider &#125; from 'mobx-react';import &#123; createStores &#125; from 'src/stores/createStores';const stores = createStores();ReactDOM.render( &lt;Provider &#123;...stores&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root') as HTMLElement);... 스토어 사용 컴포넌트 만들기 src/view/containers/Counter/index.tsx 파일을 생성 예제 이므로 components 폴더는 사용하지 않고 containers에 모두 작성 123456789101112131415161718192021222324import * as React from 'react';import &#123; observer, inject &#125; from 'mobx-react';import &#123; CounterStore &#125; from 'src/stores/CounterStore';import &#123; COUNTER_STORE &#125; from 'src/constant/stores.const';@inject( COUNTER_STORE)@observerclass Counter extends React.Component&lt;&#123;&#125;, &#123;&#125;&gt; &#123; public render() &#123; const &#123; counter, increase, decrease &#125; = (this.props[COUNTER_STORE] as CounterStore); return ( &lt;div&gt; &lt;h2&gt;Counter : &#123;counter&#125;&lt;/h2&gt; &lt;button onClick=&#123;increase&#125;&gt;Increase&lt;/button&gt; &lt;button onClick=&#123;decrease&#125;&gt;Decrease&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default Counter; @inject 컴포넌트의 props에 스토어 주입 @observer 스토어의 변화를 관찰하여 업데이트시 결과 반영 참고 mobx 공식 저장소 결과]]></content>
  </entry>
  <entry>
    <title><![CDATA[ReactNative(Expo)에 Typescript 적용]]></title>
    <url>%2F2018%2F11%2F11%2FReactNative(Expo)%EC%97%90%20Typescript%20%EC%A0%81%EC%9A%A9%2F</url>
    <content type="text"><![CDATA[ReactNative(Expo)에 Typescript 적용 정리 목적으로 작성한 글 입니다 목표 : Expo CLI를 통해 생성된 프로젝트에 Typescript 적용 환경 123Windows 10Node.js 8.11.2Expo CLI 2.X (Ver 2.x → CRNA 기능 통합, XDE 웹기반으로 변경) Expo CLI 설치 1$ yarn global expo-cli ※ 또는 npm isntall -g expo-cli 프로젝트 생성 1$ expo init &lt;Project Name&gt; ※ "blank app" 선택 Typescript관련 패키지 설치 123$ cd &lt;Project Name&gt;$ yarn add typescript react-native-typescript-transformer tslib$ yarn add @types/react @types/react-native @types/expo @types/expo__vector-icons --dev tsconfig.json 파일 생성 &amp; 수정 1$ ./node_modules/.bin/tsc.cmd --init ※ "tsconfig.json"파일 생성 1234567891011121314151617181920&#123; "compilerOptions": &#123; "target": "es2017", "module": "es2015", "lib": [ "es2017" ], "jsx": "react-native", "sourceMap": true, "noEmit": true, "importHelpers": true, "moduleResolution": "node", "allowSyntheticDefaultImports": true, "experimentalDecorators": true, "emitDecoratorMetadata": true &#125;, "exclude": [ "node_modules" ]&#125; tslint.json 파일 생성 세부 설정은 tslint 공식홈 참조 12345678910&#123; "extends": ["tslint:recommended", "tslint-react", "tslint-config-prettier"], "linterOptions": &#123; "exclude": [ "config/**/*.js", "node_modules/**/*.ts", "coverage/lcov-report/*.js" ] &#125;&#125; app.json파일 수정 12345678&#123; "expo": &#123; "packagerOpts": &#123; "sourceExts": ["ts", "tsx"], "transformer": "node_modules/react-native-typescript-transformer/index.js" &#125; &#125;&#125; 파일명 변경 12$ mkdir src$ mv App.js src/App.tsx App.ts 파일생성 12import App from './src/App';export default App; 실행 스마트 폰에 Expo앱 설치후 아래 명령어 입력 1$ expo start ※ 스마트폰에서 생성된 QR코드 스캔 결과]]></content>
      <categories>
        <category>Mobile</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>Typescript</tag>
        <tag>Expo</tag>
      </tags>
  </entry>
</search>
